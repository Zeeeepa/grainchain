"""
Integration tests for the Local provider.

These tests run locally and don't require external credentials.
They test the full integration with the local filesystem and subprocess execution.
"""

import os
import tempfile
import time
from pathlib import Path

import pytest

from grainchain import Sandbox, SandboxConfig
from grainchain.core.exceptions import SandboxError, TimeoutError
from grainchain.core.interfaces import ExecutionResult, FileInfo
from grainchain.providers.local import LocalProvider


@pytest.mark.integration
class TestLocalProviderIntegration:
    """Integration tests for Local provider with real filesystem operations."""
    
    @pytest.fixture
    def local_provider(self):
        """Create Local provider."""
        return LocalProvider()
    
    @pytest.fixture
    def local_config(self, temp_dir):
        """Create configuration for Local testing."""
        return SandboxConfig(
            timeout=30,
            working_directory=str(temp_dir),
            environment_vars={"TEST_VAR": "integration_test"},
            auto_cleanup=True
        )
    
    async def test_local_provider_create_session(self, local_provider, local_config):
        """Test creating a real Local session."""
        session = await local_provider.create_session(local_config)
        
        assert session is not None
        assert session.working_directory.exists()
        assert session.working_directory.is_dir()
        
        await session.cleanup()
        assert not session.working_directory.exists()
    
    async def test_local_sandbox_basic_execution(self, local_provider, local_config):
        """Test basic command execution in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Test simple echo command
            result = await sandbox.execute("echo 'Hello, Local!'")
            
            assert isinstance(result, ExecutionResult)
            assert result.success
            assert result.return_code == 0
            assert "Hello, Local!" in result.stdout
            assert result.execution_time > 0
    
    async def test_local_sandbox_python_execution(self, local_provider, local_config):
        """Test Python code execution in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Test Python execution
            python_code = "print('Python works locally!'); import sys; print(f'Python: {sys.version}')"
            result = await sandbox.execute(f"python3 -c \"{python_code}\"")
            
            assert result.success
            assert "Python works locally!" in result.stdout
            assert "Python:" in result.stdout
    
    async def test_local_sandbox_file_operations(self, local_provider, local_config):
        """Test file upload/download operations in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Upload a text file
            content = "This is a test file for Local integration testing."
            await sandbox.upload_file("test.txt", content)
            
            # Verify file exists by listing
            files = await sandbox.list_files("/")
            file_names = [f.name for f in files]
            assert "test.txt" in file_names
            
            # Download and verify content
            downloaded_content = await sandbox.download_file("test.txt")
            assert downloaded_content.decode() == content
            
            # Test Python file execution
            python_script = """
print("Hello from Python file!")
with open("output.txt", "w") as f:
    f.write("Generated by Python script")
print("File created successfully")
"""
            await sandbox.upload_file("script.py", python_script)
            result = await sandbox.execute("python3 script.py")
            assert result.success
            assert "Hello from Python file!" in result.stdout
            assert "File created successfully" in result.stdout
            
            # Verify the output file was created
            output_content = await sandbox.download_file("output.txt")
            assert b"Generated by Python script" in output_content
    
    async def test_local_sandbox_nested_directories(self, local_provider, local_config):
        """Test operations with nested directory structures."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Create nested directory structure
            await sandbox.execute("mkdir -p deep/nested/structure")
            
            # Upload file to nested directory
            await sandbox.upload_file("deep/nested/structure/deep_file.txt", "Deep content")
            
            # Verify file exists
            files = await sandbox.list_files("deep/nested/structure")
            file_names = [f.name for f in files]
            assert "deep_file.txt" in file_names
            
            # Download from nested location
            content = await sandbox.download_file("deep/nested/structure/deep_file.txt")
            assert content.decode() == "Deep content"
    
    async def test_local_sandbox_working_directory(self, local_provider, local_config):
        """Test working directory operations in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Check current directory
            result = await sandbox.execute("pwd")
            assert result.success
            assert str(local_config.working_directory) in result.stdout
            
            # Create subdirectory and work in it
            await sandbox.execute("mkdir subdir")
            result = await sandbox.execute("pwd", working_dir="subdir")
            assert result.success
            
            # Test file operations in subdirectory
            await sandbox.upload_file("subdir/subfile.txt", "Content in subdirectory")
            files = await sandbox.list_files("subdir")
            assert any(f.name == "subfile.txt" for f in files)
    
    async def test_local_sandbox_environment_variables(self, local_provider, local_config):
        """Test environment variables in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Test predefined environment variable
            result = await sandbox.execute("echo $TEST_VAR")
            assert result.success
            assert "integration_test" in result.stdout
            
            # Test setting and using environment variable in command
            result = await sandbox.execute("export NEW_VAR='local_value' && echo $NEW_VAR")
            assert result.success
            assert "local_value" in result.stdout
    
    async def test_local_sandbox_error_handling(self, local_provider, local_config):
        """Test error handling in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Test command that fails
            result = await sandbox.execute("nonexistent_command_12345")
            
            assert not result.success
            assert result.return_code != 0
            assert len(result.stderr) > 0
            
            # Test downloading non-existent file
            with pytest.raises(FileNotFoundError):
                await sandbox.download_file("nonexistent_file.txt")
    
    async def test_local_sandbox_timeout_handling(self, local_provider, local_config):
        """Test timeout handling in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Test command with custom timeout
            result = await sandbox.execute("echo 'quick command'", timeout=5)
            assert result.success
            
            # Test longer running command that should complete
            result = await sandbox.execute("sleep 1 && echo 'completed'", timeout=3)
            assert result.success
            assert "completed" in result.stdout
            
            # Test command that should timeout
            start_time = time.time()
            result = await sandbox.execute("sleep 10", timeout=2)
            end_time = time.time()
            
            # Should complete within timeout period (plus some buffer)
            assert end_time - start_time < 5
            # Command should fail due to timeout
            assert not result.success
    
    async def test_local_sandbox_concurrent_operations(self, local_provider, local_config):
        """Test concurrent operations in Local sandbox."""
        import asyncio
        
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Run multiple commands concurrently
            tasks = [
                sandbox.execute(f"echo 'Local Task {i}' && sleep 0.1")
                for i in range(5)
            ]
            
            results = await asyncio.gather(*tasks)
            
            assert len(results) == 5
            for i, result in enumerate(results):
                assert result.success
                assert f"Local Task {i}" in result.stdout
    
    async def test_local_sandbox_large_file_operations(self, local_provider, local_config):
        """Test operations with larger files in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Create a larger text file (about 1MB)
            large_content = "Line {}\n".format(i) * 50000  # ~350KB
            await sandbox.upload_file("large_file.txt", large_content)
            
            # Verify file was uploaded correctly
            downloaded_content = await sandbox.download_file("large_file.txt")
            assert len(downloaded_content) == len(large_content.encode())
            
            # Test processing the large file
            result = await sandbox.execute("wc -l large_file.txt")
            assert result.success
            assert "50000" in result.stdout
            
            # Test file operations
            result = await sandbox.execute("head -5 large_file.txt")
            assert result.success
            assert "Line 0" in result.stdout
    
    async def test_local_sandbox_binary_file_operations(self, local_provider, local_config):
        """Test operations with binary files in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Create binary data
            binary_data = bytes(range(256)) * 100  # 25.6KB of binary data
            await sandbox.upload_file("binary_file.bin", binary_data)
            
            # Download and verify
            downloaded_data = await sandbox.download_file("binary_file.bin")
            assert downloaded_data == binary_data
            
            # Test file size
            result = await sandbox.execute("ls -l binary_file.bin")
            assert result.success
            assert str(len(binary_data)) in result.stdout
    
    async def test_local_sandbox_snapshot_operations(self, local_provider, local_config):
        """Test snapshot creation and restoration in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Create initial state
            await sandbox.upload_file("file1.txt", "Original content 1")
            await sandbox.upload_file("file2.txt", "Original content 2")
            await sandbox.execute("mkdir original_dir")
            await sandbox.upload_file("original_dir/nested.txt", "Nested content")
            
            # Create snapshot
            snapshot_id = await sandbox.create_snapshot()
            assert snapshot_id is not None
            assert isinstance(snapshot_id, str)
            
            # Modify state
            await sandbox.upload_file("file1.txt", "Modified content 1")
            await sandbox.upload_file("file3.txt", "New file")
            await sandbox.execute("rm file2.txt")
            await sandbox.execute("rm -rf original_dir")
            
            # Verify modified state
            files = await sandbox.list_files("/")
            file_names = [f.name for f in files]
            assert "file3.txt" in file_names
            assert "file2.txt" not in file_names
            assert "original_dir" not in file_names
            
            content1 = await sandbox.download_file("file1.txt")
            assert content1.decode() == "Modified content 1"
            
            # Restore snapshot
            await sandbox.restore_snapshot(snapshot_id)
            
            # Verify restored state
            files = await sandbox.list_files("/")
            file_names = [f.name for f in files]
            assert "file1.txt" in file_names
            assert "file2.txt" in file_names
            assert "original_dir" in file_names
            assert "file3.txt" not in file_names
            
            # Verify content is restored
            content1 = await sandbox.download_file("file1.txt")
            content2 = await sandbox.download_file("file2.txt")
            nested_content = await sandbox.download_file("original_dir/nested.txt")
            
            assert content1.decode() == "Original content 1"
            assert content2.decode() == "Original content 2"
            assert nested_content.decode() == "Nested content"
    
    async def test_local_sandbox_multiple_snapshots(self, local_provider, local_config):
        """Test multiple snapshot operations in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Create first state
            await sandbox.upload_file("state1.txt", "State 1 content")
            snapshot1 = await sandbox.create_snapshot()
            
            # Create second state
            await sandbox.upload_file("state2.txt", "State 2 content")
            snapshot2 = await sandbox.create_snapshot()
            
            # Create third state
            await sandbox.upload_file("state3.txt", "State 3 content")
            
            # Verify current state has all files
            files = await sandbox.list_files("/")
            file_names = [f.name for f in files]
            assert "state1.txt" in file_names
            assert "state2.txt" in file_names
            assert "state3.txt" in file_names
            
            # Restore to snapshot1
            await sandbox.restore_snapshot(snapshot1)
            files = await sandbox.list_files("/")
            file_names = [f.name for f in files]
            assert "state1.txt" in file_names
            assert "state2.txt" not in file_names
            assert "state3.txt" not in file_names
            
            # Restore to snapshot2
            await sandbox.restore_snapshot(snapshot2)
            files = await sandbox.list_files("/")
            file_names = [f.name for f in files]
            assert "state1.txt" in file_names
            assert "state2.txt" in file_names
            assert "state3.txt" not in file_names
    
    async def test_local_sandbox_invalid_snapshot(self, local_provider, local_config):
        """Test restoring from invalid snapshot in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            with pytest.raises(ValueError, match="Snapshot not found"):
                await sandbox.restore_snapshot("invalid_snapshot_id")
    
    async def test_local_provider_multiple_sessions(self, local_provider, temp_dir):
        """Test creating multiple Local sessions."""
        sessions = []
        
        try:
            # Create multiple sessions with different working directories
            for i in range(3):
                session_dir = temp_dir / f"session_{i}"
                config = SandboxConfig(working_directory=str(session_dir))
                session = await local_provider.create_session(config)
                sessions.append(session)
                
                # Test each session independently
                await session.upload_file(f"session_{i}_file.txt", f"Content for session {i}")
                result = await session.execute(f"echo 'Session {i}'")
                assert result.success
                assert f"Session {i}" in result.stdout
        
        finally:
            # Clean up all sessions
            for session in sessions:
                await session.cleanup()
    
    async def test_local_provider_session_isolation(self, local_provider, temp_dir):
        """Test that Local sessions are properly isolated."""
        # Create first session
        session1_dir = temp_dir / "session1"
        config1 = SandboxConfig(working_directory=str(session1_dir))
        session1 = await local_provider.create_session(config1)
        
        try:
            await session1.upload_file("session1_file.txt", "Session 1 content")
            
            # Create second session
            session2_dir = temp_dir / "session2"
            config2 = SandboxConfig(working_directory=str(session2_dir))
            session2 = await local_provider.create_session(config2)
            
            try:
                # Verify second session doesn't see first session's files
                files = await session2.list_files("/")
                file_names = [f.name for f in files]
                assert "session1_file.txt" not in file_names
                
                # Add file to second session
                await session2.upload_file("session2_file.txt", "Session 2 content")
                
                # Verify first session doesn't see second session's files
                files = await session1.list_files("/")
                file_names = [f.name for f in files]
                assert "session2_file.txt" not in file_names
                assert "session1_file.txt" in file_names
                
                # Verify physical isolation
                assert session1.working_directory != session2.working_directory
                assert (session1.working_directory / "session1_file.txt").exists()
                assert not (session1.working_directory / "session2_file.txt").exists()
                assert (session2.working_directory / "session2_file.txt").exists()
                assert not (session2.working_directory / "session1_file.txt").exists()
            
            finally:
                await session2.cleanup()
        
        finally:
            await session1.cleanup()
    
    @pytest.mark.slow
    async def test_local_sandbox_data_science_workflow(self, local_provider, local_config):
        """Test a complete data science workflow in Local sandbox."""
        async with Sandbox(provider=local_provider, config=local_config) as sandbox:
            # Create a data analysis script
            analysis_script = """
import json
import csv
import statistics

# Sample data
data = [
    {"name": "Alice", "age": 25, "score": 85, "department": "Engineering"},
    {"name": "Bob", "age": 30, "score": 92, "department": "Marketing"},
    {"name": "Charlie", "age": 35, "score": 78, "department": "Engineering"},
    {"name": "Diana", "age": 28, "score": 96, "department": "Sales"},
    {"name": "Eve", "age": 32, "score": 88, "department": "Marketing"}
]

print("Data Analysis Starting...")
print(f"Total records: {len(data)}")

# Basic statistics
ages = [person["age"] for person in data]
scores = [person["score"] for person in data]

print(f"Average age: {statistics.mean(ages):.1f}")
print(f"Average score: {statistics.mean(scores):.1f}")
print(f"Max score: {max(scores)}")
print(f"Min score: {min(scores)}")

# Department analysis
departments = {}
for person in data:
    dept = person["department"]
    if dept not in departments:
        departments[dept] = []
    departments[dept].append(person["score"])

print("\\nDepartment Analysis:")
for dept, scores in departments.items():
    avg_score = statistics.mean(scores)
    print(f"{dept}: {len(scores)} people, avg score: {avg_score:.1f}")

# Save results
results = {
    "total_records": len(data),
    "average_age": statistics.mean(ages),
    "average_score": statistics.mean(scores),
    "department_stats": {
        dept: {
            "count": len(scores),
            "average_score": statistics.mean(scores)
        }
        for dept, scores in departments.items()
    }
}

with open("analysis_results.json", "w") as f:
    json.dump(results, f, indent=2)

# Save raw data as CSV
with open("data.csv", "w", newline="") as f:
    writer = csv.DictWriter(f, fieldnames=["name", "age", "score", "department"])
    writer.writeheader()
    writer.writerows(data)

print("\\nAnalysis complete! Results saved to analysis_results.json and data.csv")
"""
            
            await sandbox.upload_file("analysis.py", analysis_script)
            
            # Run the analysis
            result = await sandbox.execute("python3 analysis.py")
            assert result.success
            assert "Data Analysis Starting..." in result.stdout
            assert "Total records: 5" in result.stdout
            assert "Department Analysis:" in result.stdout
            assert "Analysis complete!" in result.stdout
            
            # Verify output files were created
            files = await sandbox.list_files("/")
            file_names = [f.name for f in files]
            assert "analysis_results.json" in file_names
            assert "data.csv" in file_names
            
            # Download and verify JSON results
            json_content = await sandbox.download_file("analysis_results.json")
            results = json.loads(json_content.decode())
            assert results["total_records"] == 5
            assert "department_stats" in results
            assert "Engineering" in results["department_stats"]
            
            # Download and verify CSV content
            csv_content = await sandbox.download_file("data.csv")
            assert b"name,age,score,department" in csv_content
            assert b"Alice" in csv_content
            assert b"Engineering" in csv_content

